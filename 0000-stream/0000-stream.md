---
title: STREAM: A Multiplexed Money and Data Transport Protocol
draft: 1
---

# STREAM: A Multiplexed Money and Data Transport Protocol

ILP/STREAM, or the STREAMing Transport for the Real-time Exchange of Assets and Messages, is an Interledger transport protocol that provides for multiplexed streams of money and data over a virtual ILP connection. STREAM is a successor to [PSK2](../0025-pre-shared-key-2/0025-pre-shared-key-2.md) and takes significant inspiration from the [QUIC](https://tools.ietf.org/html/draft-ietf-quic-transport-10) Internet transport protocol.

## Definitions

- **Client** - One of the two entities using STREAM. The Client initiates a Connection to the Server using STREAM packets sent over ILP. Because STREAM uses bidirectional streams, the Client may be either the Sender or the Receiver of a given packet.
- **Connection** - The session established between a Client and a Server. A Connection may have zero or more Money Streams and zero or more Data Streams.
- **Data Stream** - A bidirectional data channel used for structuring data sent over a Connection. Inspired by [QUIC's Bidirectional Streams](https://tools.ietf.org/html/draft-ietf-quic-transport-10#page-66).
- **Money Stream** - A bidirectional money channel used for sending money over a Connection. Users of STREAM MAY use a single Money Stream for each Connection or multiple to account for different intended purposes for the value sent.
- **Receiver** - The entity that gets a STREAM packet attached to an ILP Prepare and responds with either an ILP Fulfill or Reject packet. The Receiver may refer to either the Client or Server.
- **Sender** - The entity that sends a STREAM packet attached to an ILP Prepare. The Sender may refer to either the Client or Server.
- **Server** - One of the two entities using STREAM. The Server listens through an ILP account for incoming Connections from Clients. Note that STREAM Servers DO NOT listen for Connections over the Internet, but rather over Interledger. Because STREAM uses bidirectional streams, the Server may be either the Sender or the Receiver of a given packet.

## Overview

### Relation to Other Protocols

STREAM is designed to work with ILPv4 Prepare, Fulfill, and Reject packets.

STREAM may be used by applications or higher-level protocols for sending money and data.

### Setup

Before using STREAM, the Client and Server use an authenticated, encrypted communication channel (generally provided as part of an [Application Layer Protocol](../0001-interledger-architecture/0001-interledger-architecture.md#application-layer)) to exchange:
- A 32-byte random or pseudorandom shared secret generated by the Server
- The Server's ILP address

The Server MAY generate the shared secret from a longer-term secret and a nonce, as described in [PSKv1's Appendix A: Recommended Algorithm for Generating Shared Secrets](./0016-pre-shared-key/0016-pre-shared-key.md#appendix-a-recommended-algorithm-for-generating-shared-secrets). In this case, the Server would append the nonce (**not** the secret) to their ILP address to create the destination address they communicate to the Client.

### Multiplexed Money Streams

STREAM accounts for value sent over a Connection using the Money Stream abstraction. Money Streams are bidirectional, meaning they can be used to send value from the Client to the Server or from the Server to the Client. A Connection may include any number of Money Streams.

Money Streams use absolute amounts to track the total amounts sent and received, as well as the limits for sending and receiving. For example, the Sender might set their send maximum to 1000 to send 1000 units and the Connection would keep sending ILP Prepare packets until the total sent is equal to 1000.

Multiple Money Streams MAY be used to separately account for value sent and received for different purposes. A Money Stream can be long-lived and the send and receive limits MAY be adjusted over time (for example, in response to an application-level action) or a Money Stream can be used to account for a single logical payment, in which case it would be closed when the payment is finished.

Money Streams are identified by integers starting from 1. Odd-numbered Money Streams are initiated by the Client and even-numbered Money Streams are initiated by the Server. Money Stream identifiers are unrelated to Data Stream identifiers and a single Connection MAY have Money Streams and Data Streams with the same number.

### Multiplexed Data Streams

STREAM also offers the ability to send data through the Connection over ILP (rather than over the Internet). Data Streams are a lightweight byte-stream abstraction used for grouping data sent over the connection. They provide reliable, in-order delivery of bytes and may divide messages amongst multiple ILP packets. Data Streams are heavily inspired by [QUIC Bidirectional Streams](https://tools.ietf.org/html/draft-ietf-quic-transport-10#section-10).

Data Streams may be long-lived or they may be used for individual requests and/or response messages. For details on this, see [Streams: QUIC's Data Structuring Abstraction](https://tools.ietf.org/html/draft-ietf-quic-transport-10#section-10).

Data Streams are identified by integers starting from 1. Odd-numbered Data Streams are initiated by the Client and even-numbered Data Streams are initiated by the Server. Data Stream identifiers are unrelated to Money Stream identifiers and a single Connection MAY have Data Streams and Money Streams with the same number.

### Stream and Connection Flow Control

STREAM implements stream- and connection-level flow control. Clients and Servers communicate the maximum amount of money or data they are willing to receive on a given stream or for the connection as a whole. Limits may be changed and retransmitted throughout the life of the Connection to accept more money or data as desired by the application.

Money Streams SHOULD start with send and receive limits of zero to prevent accidental sending.

Data Streams MAY start with non-zero limits but should set the limits such that out-of-order incoming data will not exceed the buffer capacity allocated.

Connections SHOULD limit the number of Money and Data Streams to prevent a malicious Sender from opening an excessive number of streams to exhaust the Receiver's memory.

### Connection Migration

Clients and Servers MAY change the address the other entity will send packets to at any time by sending a `ConnectionNewAddress` frame with their new ILP address.

If one entity changes their address, the other SHOULD NOT assume that the asset is the same or that the exchange rate will be similar.

### Authenticated Encryption

All STREAM packets are encrypted using [AES-256-GCM](https://en.wikipedia.org/wiki/Galois/Counter_Mode) with a 12-byte Initialization Vector (IV) and a 16-Byte Authentication Tag.

If subsequent versions support additional encryption algorithms, those details should be exchanged between the sender and receiver when they establish the shared secret. If a receiver attempts to decrypt an incoming packet but is unable to (perhaps because the sender is using an unsupported cipher), the receiver SHOULD reject the incoming transfer with an `F06: Unexpected Payment` error.

### Conditions and Fulfillments

The Client and Server generate the condition and fulfillment using their shared secret. The fulfillment is computed from the shared secret and the encrypted STREAM packet. The condition is the hash of the fulfillment.

As in PSKv1 and PSKv2, this method for generating the condition and fulfillment enables many payments to be sent without end-to-end communication for each one.

### Quoting

STREAM includes the prepare amount in each packet to enable the Client and Server to determine and handle the path exchange rate. STREAM packets sent with ILP Prepare packets include the minimum destination amount the Receiver should accept, which the sender may set using the computed exchange rate. STREAM packets included in ILP Fulfill and Reject packets include the amount that arrived in the ILP Prepare packet the receiver got, which enables the sender to determine the exchange rate by dividing the destination amount by the source amount they sent.

### Differences from PSK

Unlike PSK and PSK2, STREAM handles:
- Streaming and chunked payments
- Segmenting application data to send it using multiple ILP packets

### Differences from QUIC

Unlike QUIC, STREAM:
- Has only one packet type and the shared secret identifies the Connection rather than a separate Connection ID.
- Does not include a cryptographic handshake, because STREAM assumes a symmetric secret is communicated out of band.
- Does not support unidirectional frames. The QUIC community had significant debate over whether to include unidirectional streams, bidirectional streams, or both. They settled on both primarily to support the HTTP request/response pattern as well as HTTP/2 Server Push. Unidirectional streams were left out of STREAM because they add complexity and are a premature optimization for this protocol now.
- Does not have ACK frames, because ILP Prepare packets must be acknowledged with either a Fulfill or Reject packet. If the response includes an (authenticated) STREAM packet, the sender can treat that as an acknowledgement of the control and data frames from the Prepare packet they sent.
- Does not have Ping, Path Challenge, or Path Challenge Response frames, because a STREAM packet with no frames can be used instead. As long as the Client and Server increment the packet sequence for each packet they send, a valid Fulfill or Reject packet from the Receiver that includes the correct sequence in the encrypted data serves as the path challenge and response.

## Specification

All STREAM packets are intended to be sent in the `data` of an [ILP Prepare, Fulfill, or Reject](../0027-interledger-protocol-4/0027-interledger-protocol-4.md) packet.

### Encryption

#### Encryption Envelope

See the [ASN.1 definition](../asn1/Stream.asn) for the formal specification.

| Field | Type | Description |
|---|---|---|
| Random IV  | 12-Byte UInt | Nonce used as input to the AES-GCM algorithm. Also ensures conditions are random. Senders MUST NOT encrypt two packets with the same nonce |
| Authentication Tag   | 16-Byte UInt | Authentication tag produced by AES-GCM encryption that ensures data integrity |
| Ciphertext | 0-32739 Bytes | Encrypted data (see below for contents) |

#### Encryption Pseudocode

Note that the encryption key is derived from the shared secret using an HMAC.

```
iv = random_bytes(12)
encryption_key = hmac_sha256(shared_secret, "ilp_stream_encryption")
{ ciphertext, auth_tag } = aes_256_gcm(encryption_key, iv, data)
```

### STREAM Packet

See the [ASN.1 definition](../asn1/Stream.asn) for the formal specification.

| Field | Type | Description |
|---|---|---|
| Version | UInt8 | `1` for this version |
| ILP Packet Type | UInt8 | ILPv4 packet type this STREAM packet MUST be sent in (`12` for Prepare, `13` for Fulfill, and `14` for Reject). A sender or receiver MUST discard a STREAM packet that comes in on the wrong ILP Packet Type. |
| Sequence | VarUInt | Identifier for an ILP request / resopnse. Clients and Servers track their own outgoing packet sequence numbers and increment the `Sequence` for each ILP Prepare they send. The Receiver MUST respond with a STREAM packet that includes the same `Sequence` as the Sender's Prepare packet. A sender MUST discard a STREAM packet in which the `Sequence` does not match the STREAM packet sent with their ILP Prepare. |
| Prepare Amount | VarUInt | If the STREAM packet is sent on an ILP Prepare, this represents the minimum the receiver should accept. If the packet is sent on an ILP Fulfill or Reject, this represents the amount that the receiver got in the Prepare. |
| Frames | SEQUENCE OF Frame | The rest of the packet is comprised of type- and length-prefixed Frames, as specified below. Note that the array of frames is NOT length-prefixed. |

**TODO**: Should we length-prefix the frames array and make the padding a field in the packet format to better comply with OER? Note that we cannot length-prefix the padding because in certain edge cases it could make it impossible to pad to the right length when the length prefix is included.

### Frames and Frame Types

Every frame is encoded with the type and length prefix as follows.

A receiver that gets an unknown frame type SHOULD ignore and skip it.

#### Frame Encoding

See the [ASN.1 definition](../asn1/Stream.asn) for the formal specification.

| Field | Type | Description |
|---|---|---|
| Type | UInt8 | Identifier for the frame type (see below) |
| Data | Variable-Length Octet String | Frame contents |

#### Frame Types

| Type ID | Frame |
|---|---|
| `0x01` | Connection New Address |
| `0x02` | Connection Close |
| `0x03` | Application Close |
| `0x04` | Connection Max Money |
| `0x05` | Connection Money Blocked |
| `0x06` | Connection Max Data |
| `0x07` | Connection Data Blocked |
| `0x08` | Connection Max Stream ID |
| `0x09` | Connection Stream ID Blocked |
| `0x10` | Stream Money |
| `0x11` | Stream Money End |
| `0x12` | Stream Money Max |
| `0x13` | Stream Money Blocked |
| `0x14` | Stream Money Close |
| `0x20` | Stream Data |
| `0x21` | Stream Data End |
| `0x22` | Stream Data Max |
| `0x23` | Stream Data Blocked |
| `0x24` | Stream Data Close |

#### Padding

Zero (hex `0x00`) bytes MAY be appended after the other frames, for example to ensure that all packets are the same size to minimize the information gained from passive packet analysis. A parser SHOULD stop reading once it reaches a zero byte instead of a Frame Type Identifier.
